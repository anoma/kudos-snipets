{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kudos, an intent application","text":"<ul> <li>Pseudocode description resource_logic</li> <li>Kudos in Juvix</li> </ul>"},{"location":"kudos/","title":"Kudos as resources in Juvix (WIP)","text":"<p>This code was typechecked using Juvix v0.5.4.</p> <pre><code><pre>module kudos;\n\nimport Stdlib.Prelude open;\nimport Data.Set as Set open;\n</pre></code></pre>"},{"location":"kudos/#basic-types","title":"Basic types","text":"<pre><code><pre>syntax alias Predicate := Nat;\n\nsyntax alias Hash := Nat;\n\nsyntax alias Field := Nat;\n\nsyntax alias Signature := Nat;\n\nsyntax alias Key := Nat;\n\nByte : Type := List Nat;\n\nBytes : Type := List Byte;</pre></code></pre>"},{"location":"kudos/#custom-types","title":"Custom types","text":"<pre><code><pre>type Owner :=\n  mkOwner {\n    identity : ExternalIdentity;\n    signature : Signature\n  };\n\ntype ExternalIdentity := mkExternalIdentity {key : Key};</pre></code></pre> <pre><code><pre>module Kudo;\n  type Resource :=\n    mkResource {\n      label : Hash;\n      predicate : Predicate;\n      quantity : Field;\n      value : Value\n    };\n\n  type Value :=\n    mkValue {\n      owner : Owner;\n      originator : Signature\n    };\n  \n  Env : Type := Set Predicate;\nend;</pre></code></pre> <pre><code><pre>trait\ntype isVerifiable (A : Type) := mkVerifiable {verify : A -&gt; Bool};\n\nopen isVerifiable;\n\ninstance\nvalueIsVerifiable : isVerifiable Kudo.Value :=\n  mkVerifiable (verify := \\ {_ := true});</pre></code></pre> <pre><code><pre>kudoIsVerifiable : isVerifiable Kudo.Resource :=\n  mkVerifiable (verify := \\ {k := verify (Kudo.Resource.value k)});</pre></code></pre>"},{"location":"kudos/#partial-transactions","title":"Partial transactions","text":"<pre><code><pre>type PartialTransaction :=\n  mkPartialTransaction {\n    input : List Kudo.Resource;\n    output : List Kudo.Resource;\n    extra : Bytes\n  };\n\nopen PartialTransaction;\n\nsyntax alias PTX := PartialTransaction;</pre></code></pre>"},{"location":"kudos/#evaluation-context","title":"Evaluation context","text":"<pre><code><pre>axiom env : Kudo.Env;\n\naxiom ! : {A : Type} -&gt; A;\n\nkudo_logic (ptx : PartialTransaction) : Bool :=\n  let\n    checkInputs : Bool :=\n      all\n        \u03bb {ri :=\n          let\n            cond1 : Bool := member? (Kudo.Resource.predicate ri) env;\n            cond2 : _ := true;\n            cond3 : _ := true;\n          in cond1 &amp;&amp; not (cond2 || cond3)}\n        (input ptx);\n    checkOutput : Bool :=\n      all\n        \u03bb {ri :=\n          let\n            cond1 : Bool := member? (Kudo.Resource.predicate ri) env;\n            cond2 : _ := true;\n            cond3 : _ := true;\n          in cond1 &amp;&amp; not (cond2 || cond3)}\n        (output ptx);\n    checkConnectiveValidity : Bool := true;\n  in checkInputs &amp;&amp; checkOutput &amp;&amp; checkConnectiveValidity;\n\ninstance\npartialVerifiable : isVerifiable PartialTransaction :=\n  mkVerifiable (verify := kudo_logic);</pre></code></pre> <pre><code><pre>axiom agentA : Owner;\n\naxiom sig_agentA1 : Signature;\n\naxiom type_sig_agentA1 : Signature;\n\naxiom sig_agentA2 : Signature;\n\naxiom type_sig_agentA2 : Signature;\n\naxiom agentB : Owner;\n\naxiom sig_agentB1 : Signature;\n\naxiom type_sig_agentB1 : Signature;\n\naxiom hash : {A : Type} -&gt; A -&gt; Hash;\n\nvalueA1 : _ := Kudo.mkValue (owner := agentA; originator := sig_agentA1);\n\nkudoA1 : _ :=\n  Kudo.mkResource\n    (predicate := !; label := hash agentA; quantity := 1; value := valueA1);\n\nvalueA2 : _ := Kudo.mkValue (owner := agentA; originator := sig_agentA2);\n\nkudoA2 : _ :=\n  Kudo.mkResource\n    (predicate := !; label := hash agentA; quantity := 1; value := valueA1);\n\nvalueB1 : _ := Kudo.mkValue (owner := agentB; originator := type_sig_agentB1);\n\nkudoB1 : _ :=\n  Kudo.mkResource\n    (predicate := !; label := hash agentB; quantity := 1; value := valueB1);\n\naxiom Float : Type;\n\nsyntax alias Weight := Float;\n\ntype ResourceIntentElement :=\n  | Resource\n  | WantResourceType;\n\naxiom Term : Type;\n\nsyntax alias Connective := Term;</pre></code></pre>"},{"location":"kudos/#intents-over-kudos","title":"Intents over Kudos","text":"<pre><code><pre>type ResourceIntent :=\n  mkIntent {\n    have : List (Weight \u00d7 ResourceIntentElement);\n    want : List (Weight \u00d7 ResourceIntentElement);\n    connectives : Connective\n  };\n\ntype KudoIntentElement :=\n  | KudoResource\n  | WantKudoResourceType;\n\n{-- Each Agent can produce intents over which Kudos they have and which Kudos\n  they want, for arbitrary size vectors of both. --}\ntype KudoIntent :=\n  mkKudoIntent {\n    have : List (Weight \u00d7 KudoIntentElement);\n    want : List (Weight \u00d7 KudoIntentElement);\n    connectives : Connective\n  };</pre></code></pre>"},{"location":"resource_logic/","title":"Resource Logic","text":"<p>What follows is an explanation of the encoding of Kudos and Intents over them as <code>Resources</code> with a corresponding <code>Resource Logic</code>. </p> <pre><code>// Kudos\n// Multi-Agent, Multi-Resource swaps over Resource Types tied to Identities\n// -- Kudos as Resources --\n\nstruct KudoResource {\n    predicate: Predicate,   // kudo_logic\n    label: FFElement,       // (Hash of the) ExternalIdentity of the Originator, might need to be resolved to the actual ExtID\n    quantity: FFElement,    // Encoding of Nat? Or are they also be native FFElements?\n    value: KudoValue,       // Application Data\n} // Predicate and Value will be encoded as Program Field Elements\n\n// Kudos are fungible iff (kudoA1.predicate == kudoA2.predicate &amp;&amp; kudoA1.label == kudoA2.label)\n\nstruct KudoValue {\n    owner: ExternalIdentity,        \n    owner_sig: Signature,\n    originator_sig: Signature, // Signature over Predicate and Label (Resource Type)\n}\n\nstruct ExternalIdentity {\n    key: Key,\n}\n\nimpl ExternalIdentity {\n    fn verify(self, bytes: [Byte], sig: Signature) -&gt; bool {\n        // if sig is valid signature from self\n        //    return true\n        // otherwise\n        //    return false\n    }\n}\n\nstruct PTX {\n    input_resources: Vec&lt;Resource&gt;,\n    out_resources: Vec&lt;Resource&gt;,\n    extra_data: Vec&lt;Byte&gt;,\n}\n\n// Evaluation context\n// The evaluation context (ctx) consists of a single PTX and some \"system calls\" providing extra functionality \n// we do not want to, or can not implement inside of a resource logic.\n// During evaluation, the predicates from all resources get applied to the PTX one after another.\n//\n// \"Syscalls\":\n// - self_hash: since some logics will need to know about their own hash/address, and trying to compute the hash from \n//   inside the logic (\"self.hash(self)\") is not possible since there is no fixed point, the ctx needs to provide the \n//   hash of each resource_logic to itself. \n//   The ctx would then replace the term \"self_hash\" in a resource_logic by the corresponding hash during evaluation.\n// - verify: since we do not want to implement cryptographic primitives in the logics, the ctx should provide them by \n//   taking (Data, Key) as arguments and returning Bool. For the prototype, keys can be of type Bool with \n//   check_signature just returning the value from the key.\n\n\n\n// The following is called at validation time (taiga to be used in the shielded case).\nfn kudo_logic(ptx: Ptx) -&gt; bool {\n    for ri in ptx.resources.input {\n        if ri.predicate == env.hash_self { // if the Resource is a Kudo\n            if not ri.label.verify([ri.predicate.as_bytes()++ri.label.as_bytes()], r.value.originator_sig) {\n                return false // fail on invalid originator 1/2\n            } // check if Value contains a valid signature of the originator, denoted by the label\n              // since label is external Identity, we can call verification of a signature\n        if not ri.value.owner.verify(ri.as_bytes, ri.value.owner_sig) {  \n                return false  // if sig is valid, owner has authorized consumption\n            }\n        }\n        // Check:\n        // If a kudo without owner_sig is consumed, the only kudo that can be created is one that has the same contents + owner_sig\n    }\n\n    for ro in ptx.resources.output {\n        if ro.predicate == env.hash_self {\n            if ro.label.verify(r.value.originator_sig) == false {\n                return false // fail on invalid Originator 2/2\n            }\n        }\n        // Check:\n        // Balance per owner and resource type should be implicit to authorized consumption + balance check per type \n    }\n\n    // Check connective validity\n    if ptx.extra_data.connectives == false {\n        return false\n    }\n\n    return true\n} \n// In addition to validating the resource logic, balance checks per resource type are always performed. \n\n// -- Example Resources --\nlet valueA1 = KudoValue {\n    owner: agentA,\n    owner_sig: sig_agentA1,\n    originator_sig: type_sig_agentA1,\n}\n\nlet kudoA1 = KudoResource {\n    predicate: kudo_logic,\n    label: hash(agentA)\n    quantity: 1,\n    value: valueA1,\n}\n\nlet valueA2 = KudoValue {\n    owner: agentA,\n    owner_sig: sig_agentA2,\n    originator_sig: type_sig_agentA2,\n}\n\nlet kudoA2 = KudoResource {\n    predicate: kudo_logic,\n    label: hash(agentA)\n    quantity: 1,\n    value: valueA2,\n}\n\nlet valueB1 = KudoValue {\n    owner: agentB,\n    owner_sig: sig_agentB1,\n    originator_sig: type_sig_agentB1,\n}\n\nlet kudoB1 = KudoResource {\n    predicate: kudo_logic,\n    label: hash(agentB)\n    quantity: 1,\n    value: valueB1,\n}\n// Analogously for B2, C1, C2\n\n// -- Intents over Kudos --\n\n// To encode simple preferences for independent Resources, agents can weigh each Resource. \n// This encodes how much they value having a certain Resource. \n// In other words: For Resources they already have Agents prefer to not trade ones with high weights.\n//      Inversely, for Resources they want they prefer to trade for the ones with high weights.\n//\n// This enables, e.g. a CSP solver to optimize outcomes locally in respect to the assignment of the formula\n// by scaling boolean variables.\n\ntype Weight = Float;\n\n// A general Intent would look like this:\nenum ResourceIntentElement { // TODO: Find a better name, if we think this is an important object \n    Resource,         // This could be a resource that an agent owns, or a fully specified resource they want.\n    WantResourceType  // This specifies the Type (Predicate + Label) of a Resource an agent wants and requires Value.owner set to the intent creating agent.\n}\n// Note: Want ResourceType is only used for output resource types, to get the owner right, balance checks enforce inputs of the same type to exist.\n\n// Note: We might also introduce HaveResourceType later, in case agents want to publish intents e.g. for 3rd parties to perform a swap.\n\n// Agents might want to express inclusionary (OR) or exclusionary (XOR) preferences. \n// Inclusionary means they want to give or get either or all resources from a clause.\n// Exclusionary means they want to give or get exactly one subclause.\n// To be compatible with the CSP backend these should have a standard form as follows:\n//\n// let have0..2, want0..2 be ResourceIntentElements\n//\n// have: (have 0) XOR (have 1 OR have 2)\n// want: (want 0 OR want 1) XOR (want2 )\n//\n// During validation of the connective, only the Resource(Type) and have/want property should be relevant, \n// i.e. validation should be invariant against the relative positions of haveI, haveJ. \n//\n// TODO: We should specify this more precisely, e.g. via a BNF\ntype Connective = Term;\n\n// Intents like the following (or a flat string representation as above) would be generated to be ingested by solvers, \n// which in turn produce transactions to be validated. Validation and solving time should be fully disjoint in practice. \nstruct ResourceIntent {\n    have: Vec&lt;(Weight, ResourceIntentElement)&gt;,\n    want: Vec&lt;(Weight, ResourceIntentElement)&gt;,\n    connectives: Connective,\n}\n// This would be encoded as a PTX as follows:\n// - elements of have as input_resources\n// - elements of want as ephemeral output_resource \n// - ephemeral resources required for balancing on both sides are inferred\n// - solver hints encode the weights and connectives in ptx.extra_data\n//\n// Note: The layout here is kept close to what a PTX looks like for clarity of explanation,\n// but more concise representations can be chosen for Juvix in the service of improving UX.\n\n// Since Agents might know which type of Kudo they seek, but not all the details of the Resource, \n// we want to enable intents over Kudo Resource Types.\nenum KudoIntentElement {\n    KudoResource,\n    WantKudoResourceType, // As WantResourceType, but with Predicate = kudo_logic\n}\n\n// Each Agent can produce intents over which Kudos they have and which Kudos they want, for arbitrary size vectors of both.\nstruct KudoIntent {\n    have: Vec&lt;(Weight, KudoIntentElement)&gt;,\n    want: Vec&lt;(Weight, KudoIntentElement)&gt;\n    connectives: Connective,\n} \n// For an example intent and solver see: https://github.com/anoma/kudos-snippets/blob/main/intents_stand_mix.ipynb\n\n// Functionality of the VM that is needed:\n// - signature scheme accessible via opcode\n// - predicate.hash(self) provided via \"syscall\"\n// - API to \"send\" a kudo to someone\n// - API to check kudos I have\n\n// TODOs for V2:\n// - multi round solving/pathfinding, in case intents can not be satisfied locally on a single solver\n// - bundle splitting, to handle resources with quantity &gt; 1 \n</code></pre>"}]}