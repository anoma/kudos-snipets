--- # Kudos
--- Multi-Agent, Multi-Resource swaps over Resource Types tied to Identities
--- Ref: https://github.com/anoma/kudos-snippets/blob/main/resource_logic.md
module ResourceLogic;

import Stdlib.Prelude open;

-- import Data.Map open;
import Data.Set open;

syntax alias Predicate := Nat;
syntax alias Hash := Nat;
syntax alias Field := Nat;

syntax alias Signature := Nat;
syntax alias Key := Nat;

Byte : Type := List Nat;

Bytes : Type := List Byte;

type Owner :=
  mkOwner {
    identity : ExternalIdentity;
    -- what is this?
    signature : Signature
  };

type ExternalIdentity := mkExternalIdentity {key : Key};

module Kudo;
  
  type Resource :=
    mkResource {
      label : Hash;
      predicate : Predicate;
      quantity : Field;
      value : Value
    };

  type Value :=
    mkValue {
      owner : Owner;
      originator : Signature
    };

  Env : Type := Set Predicate;
-- TODO
end;


-- TODO


--- PTX



{-
Note: the execution environment (env) needs to provide the hash of each resource_logic to the respective predicates (hash_self), since they need it for verification, but we can't hash(self) within self, because self.hash(self) is not a fixed point
-}


axiom agentA : Owner;

axiom sig_agentA1 : Signature;

axiom type_sig_agentA1 : Signature;

axiom sig_agentA2 : Signature;

axiom type_sig_agentA2 : Signature;

axiom agentB : Owner;

axiom sig_agentB1 : Signature;

axiom type_sig_agentB1 : Signature;

axiom hash : {A : Type} -> A -> Hash;

valueA1 : _ :=
  Kudo.mkValue (owner := agentA; originator := sig_agentA1);

kudoA1 : _ :=
  Kudo.mkResource
    (predicate := !;
    -- kudo_logic,
    label := hash agentA;
    quantity := 1;
    value := valueA1);

valueA2 : _ :=
  Kudo.mkValue (owner := agentA; originator := sig_agentA2);

kudoA2 : _ :=
  Kudo.mkResource
    (predicate := !;
    -- kudo_logic,
    label := hash agentA;
    quantity := 1;
    value := valueA1);

valueB1 : _ :=
  Kudo.mkValue
    (owner := agentB; originator := type_sig_agentB1);

kudoB1 : _ :=
  Kudo.mkResource
    (predicate := !;
    -- kudo_logic,
    label := hash agentB;
    quantity := 1;
    value := valueB1);

axiom Float : Type;

syntax alias Weight := Float;

type ResourceIntentElement :=
  | Resource
  | WantResourceType;

axiom Term : Type;

syntax alias Connective := Term;

type ResourceIntent :=
  mkIntent {
    have : List (Weight × ResourceIntentElement);
    want : List (Weight × ResourceIntentElement);
    connectives : Connective
  };

type KudoIntentElement :=
  | KudoResource
  | WantKudoResourceType;

{-- Each Agent can produce intents over which Kudos they have and which Kudos
  they want, for arbitrary size vectors of both. --}
type KudoIntent :=
  mkKudoIntent {
    have : List (Weight × KudoIntentElement);
    want : List (Weight × KudoIntentElement);
    connectives : Connective
  };
